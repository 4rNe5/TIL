프로그램이 실행되면 OS가 메모리 공간을 할당해주는데 Code, Data, Heap, Stack 4개로 나뉜다.

![](https://user-images.githubusercontent.com/74440939/205225291-03abc2a2-c474-4f69-ba2c-a7dc3aec3e09.png)

# Code
우리가 작성한 소스코드가 저장되는 영역이다.

- 소스코드를 **기계어 형태 (0, 1)** 로 변경하여 저장한다.
- **컴파일 타임**에 결정되고, 중간에 코드가 변경되면 안되니 **Read-Only**로 저장된다.


# Data
이름 그대로 데이터를 저장하는 영역이다.

- **전역 변수, static 변수**가 저장된다.
```swift
enum Constant {
    static let apiKey = ""
}

var name = "baegteun"
var number = 18
```

- 프로그램의 시작과 동시에 할당되고, 프로그램이 **종료되어야 해제**된다.
- 실행 도중 값이 변경될 수도 있으니 **Read-Write**로 저장된다.


# Heap
데이터 크기가 확실하지 않은 **가변적인 데이터 타입**들이 저장되는 영역이다.

- 4개의 영역중 유일하게 **런타임**에 결정된다.
- Heap영역에는 임의의 주소값에 해당 메모리를 할당한다.
  - 임의의 값에 해당하기 때문에 주소를 찾아가는 것에 대한 오버헤드가 크다.
- 메모리 할당, 해제가 하나의 명령어로 처리되지 않기 때문에 관리가 어렵다.
- 메모리가 올라갔는지 아닌지 계속 추적하는 **Reference Counting**이 필요하다.
  - **ARC**에 의해 Reference Counting이 관리된다.
- **스레드들이 공유**하는 영역이기 때문에 **thread-safety**하지 않다.
  - 이를 관리하기 위해서는 Lock같은 자원이 필요하고 이것이 오버헤드로 이어진다.

class의 인스턴스, closure, 가변적인 String, Array같은 타입들이 Heap영역에 저장된다.


# Stack
함수의 호출과 관련된 **지역 변수, 매개변수**들이 저장되는 영역이다.

- Stack은 선형의 단순한 구조이면 시간 복잡도가 O(1)이다. 즉, 할당과 해제가 **빠르고 효율적**이다.
  - CPU에 의해 관리되고 최적화 돼서 속도가 매우 빠르다.
- 함수가 종료되면 저장된 메모리도 해제된다.
- **컴파일 타임**에 결정되기 때문에 무한히 할당할 수 없다.
- 컴파일 단계에서 언제 생성되고 해제되는지 알 수 있는 struct와 같은 값들이 저장된다.
  - 단, struct가 protocol을 채택하는 경우에는 **Heap영**역에 저장된다.
- 스레드 별로 독립적인 Stack 영역을 가지고 있기 때문에 **thread-safety** 하다.
  

# Heap과 Stack의 관계
Heap 영역은 메모리의 낮은 주소 -> 높은 주소의 방향으로 할당된다.

Stack 영역은 메모리의 높은 주소 -> 낮은 주소의 방향으로 할당된다.