## 싱글톤이 무엇인가?
싱글톤은 모든 개발자에게 잘 알려진 디자인 패턴이며 모든 새로운 개발자들이 사랑하는 디자인 패턴이다. 나는 모든 코스나 튜토리얼 시리즈가 이 디자인 패턴을 사용하고 어느 시점까지 사용해도 괜찮기 때문에 모든 새로운 개발자들을 말하고 있다.

잠깐, 싱글톤을 어떻게 사용하는지 모르나요?

걱정하지 마세요. 사용하기 가장 쉽습니다.

객체의 범위에서 `static let` 키워드를 사용하여 해당 객체의 인스턴스를 만든 다음 해당 클래스의 이니셜라이저를 `private`로 만들어야 합니다. 이니셜라이저를 `private`로 만들지 않으면, 원하는 만큼 그 객체의 인스턴스를 만들 수 있으며, 정말 나쁜 일입니다. 당신은 그 객체의 인스턴스가 하나만 있는지 확인해야 합니다.

여러분 모두는 사용하기 쉽지만 때로는 가장 쉬운 경로가 큰 문제를 일으킬 수 있다는 것을 알 수 있습니다. 무슨 문제냐고요?

결국 싱글톤은 글로벌이고 모든 스레드에서 액세스할 수 있기 때문에 스레드 문제가 발생하고, 사용자 정의할 수 없는 클래스를 얻고, 테스트할 수 없는 클래스를 얻고, 테스트 목적으로 종속성을 바꿀 수 없습니다. 그건 큰 일이 아니야, 그렇지? 농담이야!

싱글톤 문제에 뛰어들기 전에, 제가 이 글을 위해 만든 프로젝트를 살펴보고 어떻게 사용하는지 봅시다.

## 싱글톤의 사용

저는 이 프로젝트에 MVVM을 사용하고 있습니다. 우리는 서비스 레이어, 뷰 레이어, 뷰 모델 레이어 및 모델 레이어를 갖게 될 것입니다.

Https://jsonplaceholder.typicode.com 의 Mock 데이터를 사용하여 실제 애플리케이션을 시뮬레이션하기 위해 API 요청을 하고 있습니다.

나는 RealDataService라는 서비스 계층을 만들었다. 그것은 API 요청을 할 책임이 있을 것이다.

![](https://miro.medium.com/max/1400/1*ERedtGOOTMKbSvcp84f0WQ.png)

`shared`라는 인스턴스가 있으며 `static let` 이며, RealDataService의 이니셜라이저도 private입니다.

Result Type, @escaping closure 및 URLSession 등은 이 글의 범위가 아니며, 이미 알고 있다고 가정합니다.

![](https://miro.medium.com/max/1400/1*WHQrWZhzBzY-_V6QlHgrnw.png)

여기 우리의 ViewModel. 우리는 getPosts() 함수에서 싱글톤에 도달하고 downloadPosts 함수를 사용하고 있습니다. 성공하면, HomeViewModel의 게시물 변수가 보기에 이벤트를 보낼 것입니다.

![](https://miro.medium.com/max/1374/1*ttg_i88GhtqS5eFvL60lxg.png)

여기 우리의 view, 일명 ViewController. 우리는 HomeViewModel을 초기화했고 HomeViewModel에서 게시물 변수의 변경 사항을 듣고 있습니다.

그게 다야, 싱글톤을 그대로 사용하는 것.

그것의 단점에 대해 이야기할 시간이다.


## 싱글턴의 문제는 무엇인가요?

싱글턴은 꽤 잘 작동하지만, 3가지 주요 문제가 있다.

1. 싱글톤은 글로벌이다.
2. 클래스의 이니셜라이저를 사용자 정의할 수 없습니다.
3. 종속성을 바꿀 수 없습니다.

## 싱글톤은 글로벌하다

그것들은 글로벌적이며, 이는 앱의 모든 곳에서 접근할 수 있다는 것을 의미합니다. 인스턴스를 만들지 않고, 다른 클래스, 클래스의 메서드에서 직접 또는 클래스의 범위에 있지 않은 싱글톤에 액세스할 수 있습니다.

아마 너는 그런 말을 할 수 있을 거야, "그래서 뭐? 그건 완벽해, 그렇지 않니? 내가 원하는 곳 어디에서나 접근할 수 있어."

우리는 Swift안의 멀티스레드 환경에 있기 때문에, 동시에 다른 작업을 수행할 수 있는 많은 스레드가 있습니다.

![](https://miro.medium.com/max/1400/1*NImcB4pYsruo0-5w13_baw.jpeg)

클래스 인스턴스는 Heap에 저장되며, 싱글톤을 사용하기 때문에 클래스의 인스턴스는 하나만 있으며 동시에 다른 스레드에서 해당 인스턴스에 도달할 수 있습니다.

동시에 다른 스레드에서 해당 인스턴스에 도달하면 `Swift Access race` 오류가 발생하고 앱이 충돌할 것입니다.

## 사용자 정의가 불가능한 이니셜라이저

이 때문에 매개 변수를 받을 수 없기 때문에 해당 클래스 내에서 클래스를 초기화하고 있습니다. URL이나 다른 것으로 싱글톤 클래스를 초기화하고 싶지만 할 수 없기 때문에 이것은 문제입니다.

## 당신은 의존성을 바꿀 수 없습니다.

의존성을 바꾸나요? 그게 무슨 뜻인가요?

더 큰 앱에서는 아마도 하나 이상의 서비스가 있을 것이며, 당신의 클래스가 다른 데이터 서비스를 위해 잘 작동하는지 확인하기 위해 테스트를 해야 합니다. 일반적으로 더 큰 앱은 테스트 목적이나 실제 데이터 서비스를 망치지 않기 위해 Mock 데이터 서비스를 사용합니다. 우리는 이것을 하기 위해 프로토콜을 사용한다. 프로토콜?

프로토콜은 특정 작업이나 기능에 적합한 방법, 속성 및 기타 요구 사항의 청사진을 정의합니다. 그런 다음 프로토콜은 이러한 요구 사항의 실제 구현을 제공하기 위해 클래스, 구조 또는 열거형에 의해 채택될 수 있다. 프로토콜의 요구 사항을 충족하는 모든 유형은 해당 프로토콜을 준수한다고 한다.

우리는 싱글톤에 대한 3가지 주요 문제를 배웠지만 싱글톤 대신 무엇을 사용해야 하는지 배우지 못했다.

## 의존성 주입

의존성 주입은 싱글톤의 사용을 피하고 코드를 테스트에 더 좋게 만들고 종속성을 쉽게 교환할 수 있는 방법입니다. 그것은 너무 복잡하다고 생각하지만 그렇지 않다. 모든 뷰에 종속성을 주입하고, 그 종속성이 필요한 모델을 보기만 하면 됩니다. 그게 다야, 복잡하지 않아.

우리의 예에서, RealDataService 내에서 의존성을 초기화하는 대신(이 경우 우리의 의존성은 RealDataService가 될 것입니다). 우리는 앱에서 거의 초기에 거의 앱 시작 부분에서 초기화한 다음 나머지 앱에 주입해야 합니다.

우리는 그것을 싱글톤으로 초기화했지만 더 이상 그렇게 하지 않을 것이다. 우리는 앱의 시작 부분에서 종속성을 초기화할 것입니다, 제 말은 SceneDelegate.swift 파일에서 의미합니다.

뷰 모델에서 그 종속성이 필요하므로 필요한 종속성으로 초기화해야 합니다. 또한 우리는 뷰 내에서 뷰 모델을 초기화할 것이므로, 필요한 종속성으로 뷰도 초기화해야 합니다.

우리가 교실에 있고, 교실에 3개의 책상이 있다고 상상해 봅시다.

우리의 예에서 연필이 우리의 의존성이라고 가정해 봅시다.

첫번째 책상과 두번째 책상은 연필이 없지만 세번째 책상에 있는 세번째 사람으로서 우리는 착하고 연필을 가지고 있다. 두 번째 분에게는 연필 2개를 주고, 두 번째 분은 첫 번째 분에게 연필 1개를 줍니다.

우리 모두 연필이 있습니다.

첫 번째 데스크은 ViewModel입니다.
두 번째 데스크은 View입니다.
세 번째 데스크는 SceneDelgate입니다.
SceneDelgate(3번째) - > View(2번째) - > ViewModel(1번째)

그래서 우리는 뷰와 뷰 모델에 의존성을 주입했다.

![](https://miro.medium.com/max/1400/1*RHxceV5B1_ZMOFnNZ-VqKg.png)

RealDataService 클래스에서 싱글톤을 제거했습니다.

![](https://miro.medium.com/max/1400/1*KWNhSfN9y8Um32eQkl7Rsg.png)

우리는 필요한 종속성(RealDataService)으로 뷰 모델을 초기화하고 있습니다.

![](https://miro.medium.com/max/1336/1*Qlqf6QoJj7uvW2VRZh3W6w.png)

뷰 모델은 필요한 종속성으로 초기화되어야 하지만 뷰에는 해당 종속성이 없으므로 필요한 종속성으로 뷰도 초기화해야 합니다. (우리는 우리의 의존성을 뷰 모델에 주입하고 있다.)

![](https://miro.medium.com/max/1400/1*b1irngKJp_3zVAj07X5v-Q.png)

우리는 우리의 의존성을 View에 주입하고 있다.

![](https://miro.medium.com/max/1400/1*6sTb3Z2k5vz9OhhLQHatHA.png)

여기 게시물의 제목이 있습니다. 우리는 api에서 성공적으로 데이터를 얻었습니다.

그게 전부야, 우리는 우리의 관점과 관점 모델에 의존성을 주입했어. 우리는 SceneDelegate에서 종속성을 초기화했지만 SceneDelegate에서 모든 종속성을 초기화할 수는 없습니다. 두 번째 보기가 있고 버튼을 탭하면 두 번째 보기로 이동합니다. 또한 두 번째 뷰에 대한 다른 데이터 서비스가 있다고 가정해 봅시다. 이 경우 필요한 종속성으로 해당 뷰를 초기화해야 하며 첫 번째 뷰(HomeVC) 내에서 종속성을 초기화하고 두 번째 뷰에 주입해야 합니다.

우리는 우리의 첫 번째 문제를 해결했다. 우리는 싱글톤을 사용하지 않기 때문에 "싱글톤은 글로벌" 문제를 해결했습니다.

하지만 다른 사람들은 어때?

의존성의 초기화를 사용자 정의했나요?

우리가 의존성을 바꿨나요?

아니 우리는 아직 하지 않았지만 그럴 거야.

## 우리의 의존성을 위한 맞춤형 이니셜라이저

URL 문자열과 같은 추가 데이터로 종속성을 초기화하려면 어떻게 해야 하나요? 문제 없습니다, 우리는 종속성의 이니셜라이저를 사용자 정의하고 원하는 데이터를 전달할 수 있습니다.

우리의 예에서 URL 주소를 유지하는 문자열을 종속성에 전달해 봅시다.

![](https://miro.medium.com/max/1002/1*Q2TXDN9c6SsukZhroCiIHQ.png)

우리는 이니셜라이저를 사용자 정의했습니다. RealDataService를 초기화할 때 문자열을 전달해야 합니다.

![](https://miro.medium.com/max/1274/1*4pCHOa6km8Dx700e_J8KZg.png)

우리는 방금 사용자 정의가 불가능한 이니셜라이저 문제인 두 번째 문제를 해결했습니다.

## 프로토콜은 어때?

종속성을 바꾸는 것은 큰 앱에 필수적이다. 우리는 왜 그것이 필요한지에 대해 조금 이야기했다. 우리는 이 앱을 테스트하고 RealDataService가 아닌 모델을 보고 볼 수 있는 다른 데이터 서비스를 제공하기 때문에 종속성을 교환할 수 있기를 원하므로 뷰 모델, 뷰 또는 기타 데이터 레이어가 해당 종속성에 어떻게 반응하는지 관찰할 수 있습니다. 우리의 의존성을 교환할 수 있기를 바라는 많은 이유가 있다.

프로토콜이 들어오는 곳.

우리의 예를 보세요, 우리는 RealDataService를 뷰와 뷰 모델에 주입하고 있습니다. 하나의 데이터 서비스가 아닌 프로토콜을 주입하면 어떻게 될까요?

프로토콜을 만들고 "DataServiceProtocol"이라는 이름을 지정합시다.

![](https://miro.medium.com/max/1400/1*Ody1ADAiIAMBERumwKhcBQ.png)

프로토콜은 클래스의 청사진이 될 것이며, DataServiceProtocol을 클래스에 준수할 때 downloadPosts() 함수를 구현해야 합니다.

우리는 프로토콜을 만들었고, DataServiceProcotol을 매개 변수로 기대하고 DataServiceProtocol을 인수로 준수하는 클래스를 전달했습니다.

![](https://miro.medium.com/max/1400/1*cbglK7Zeq_ZggnhBxwVIBA.png)

우리의 RealDataService 프로토콜은 DataServiceProtocol을 준수하며 우리 클래스에는 downloadPosts 메서드가 있으므로 오류가 발생하지 않습니다.

또한 뷰 모델과 뷰의 이니셜라이저 매개 변수 유형을 DataServiceProtocol로 변경해야 합니다.

![](https://miro.medium.com/max/1400/1*JF6v9Zlfg66Q1ElB8sqHcA.png)

dataService 유형이 뷰 모델에서 DataServiceProtocol로 변경되었습니다.

![](https://miro.medium.com/max/1400/1*3BCFLJ6OTWCeERo_JMQiIQ.png)

HomeVC는 DataServiceProtocol을 준수하는 클래스를 기대하고 있다.

![](https://miro.medium.com/max/1278/1*I9CO606LfvYd1rG0kGePvg.png)

HomeVC에 대한 인수로 RealDataService를 전달하고 HomeVC는 DataServiceProtocol을 준수하는 클래스를 기대하고 있습니다.

지금 우리는 DataServiceProtocol을 우리의 견해에 준수하는 클래스를 주입해야 합니다. RealDataService는 DataServiceProtocol을 준수하기 때문에 추가 작업을 할 필요가 없습니다. 우리의 모든 코드는 제대로 작동할 것이다.

요약해 봅시다.

1. 우리는 프로토콜을 만들었고 "DataServiceProtocol"이라는 이름을 붙였다.
2. 우리는 프로토콜에 body가 없는 기능을 넣었다.
3. DataServiceProtocol을 RealDataService에 준수하기 때문에 필요한 downloadPosts() 함수를 구현해야 하지만 이미 RealDataService에 해당 기능이 있으므로 추가 작업이 필요하지 않습니다.
4. DataServiceProtocol을 매개 변수로 두세요.
5. DataServiceProtocol을 뷰 및 뷰 모델에 준수하는 종속성을 주입하십시오.

## 의존성 교환기

당신은 스스로에게 "좋아요, 하지만 우리는 우리의 의존성을 바꾸지 않았습니다, 우리가 그것을 만들 수 있을까요?"라고 스스로에게 물어볼 수 있습니다. 이게 마지막 단계야. 모의 데이터 서비스를 만들고 그 데이터 서비스를 우리의 보기 및 보기 모델에 주입합시다.

MockDataService 클래스를 만들고 DataServiceProtocol을 준수합시다.

![](https://miro.medium.com/max/1400/1*NeBJbEL_lUeujalmY69TXg.png)

Xcode는 우리가 필요한 기능을 구현하지 않았기 때문에 우리에게 소리친다.

![](https://miro.medium.com/max/1400/1*NS-cT-XjM4DYOjGuGqJWkw.png)

여기 우리가 필요한 기능. 우리는 이 기능에서 게시물 다운로드 과정을 시뮬레이션할 것입니다.

![](https://miro.medium.com/max/1400/1*TaUJce3ZWWfzFsjZ0RtMlQ.png)

우리의 일은 이 MockDataService로 끝났다. 우리는 포스트 배열을 매개 변수로 기대하고 있으며 그 배열을 클로저가 있는 뷰 모델로 보낼 것입니다. 다운로드 프로세스를 시뮬레이션하고 있기 때문에 1초 후에 완료 블록을 실행할 것입니다.

포스트 어레이로 MockDataService를 초기화하고 HomeVC에 주입하는 한 단계만 있을 것입니다.

![](https://miro.medium.com/max/1400/1*7CnF8TBTrNSwLqBELjNR3w.png)

우리는 게시물을 만들고 그 게시물로 MockDataService를 초기화했습니다.

응, 그게 다야. 우리는 프로토콜 덕분에 MockDataService를 앱의 나머지 부분에 주입했습니다. 그게 실제로 작동하는지 보자.

![](https://miro.medium.com/max/1052/1*-C6JuIsAsx3-enemABSXSw.png)

응, 콘솔이 우리 게시물 제목을 인쇄하고 있어.

## 끝

우리는 싱글톤, 프로토콜 및 의존성 주입에 대해 이야기했습니다.

우리는 싱글톤에 대한 3가지 주요 문제와 그 문제를 피하는 방법을 배웠습니다. 우리는 의존성 주입이 필요한 이유와 의존성을 주입하는 방법에 대해 이야기했습니다. 우리는 의존성을 교환할 수 있게 만들고 일부 데이터로 초기화했습니다.

저는 당신이 무언가를 배웠기를 바라며 싱글톤과 의존성 주입의 개념을 이해했기를 바랍니다.